
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions
    function isAuthenticated() {
      return request.auth != null;
    }

    // Assumes admin users have a custom claim: request.auth.token.isAdmin == true
    function isAdmin() {
      return isAuthenticated() && request.auth.token.isAdmin == true;
    }

    function isTeacher() {
      return isAuthenticated() && exists(/databases/$(database)/documents/teachers/$(request.auth.uid));
    }

    function isSelf(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    // Students collection
    // Document ID is the 10-digit studentId
    match /students/{studentId} {
      // Admins can read all student data. Teachers can read student data (e.g., for class lists).
      // Student-specific read access is typically handled by client-side logic querying by their known ID.
      allow read: if isAdmin() || isTeacher();
      
      // Only admins can create, update, or delete student records.
      // Ensure studentId field in the document matches the document ID.
      allow create: if isAdmin() && request.resource.data.studentId == studentId;
      allow update: if isAdmin(); // Admins can update any field. For studentId field, ensure it's not changed or matches doc ID.
      allow delete: if isAdmin();
    }

    // Teachers collection
    // Document ID is the teacher's Firebase Auth UID
    match /teachers/{teacherUid} {
      // Admins and the teacher themselves can read teacher profiles.
      // Other teachers might also need to read profiles (e.g., for a staff directory).
      allow read: if isAuthenticated(); 
      
      // Admins can create teacher profiles (during registration).
      // Ensure the 'uid' field in the document matches the teacher's Auth UID.
      allow create: if isAdmin() && request.resource.data.uid == teacherUid;
      
      // Admins can update any teacher profile. Teachers can update their own profile.
      allow update: if isAdmin() || (isTeacher() && isSelf(teacherUid) && request.resource.data.uid == teacherUid);
      
      // Only admins can delete teacher profiles.
      allow delete: if isAdmin();
    }

    // Payments collection
    // Document ID is auto-generated by Firestore or custom (e.g., RCPT-xxxx)
    match /payments/{paymentId} {
      // Admins can read all payments.
      // Students should only read their own payments (requires client to query by studentId).
      // Rule for student: allow read if resource.data.studentId == <student_id_passed_by_client_somehow_or_verified_by_function>
      // This example is simplified; secure student-specific reads often need a backend function.
      allow read: if isAdmin(); 
      // Consider adding student read access if direct client query by studentId is acceptable:
      // allow read: if isAdmin() || (isAuthenticated() && resource.data.studentId == request.query.studentId); // CAUTION: request.query is not directly available in rules.
      // A better approach for student reading their payments would be a Callable Function.
      // For now, admin read access is primary.

      // Admins record payments.
      allow create: if isAdmin();
      // allow update, delete: if isAdmin(); // If needed in the future
    }

    // App Settings (e.g., /appSettings/general)
    match /appSettings/{settingId} {
      // Publicly readable for branding, school name, etc.
      allow read: if true; 
      // Only admins can change app settings.
      allow write: if isAdmin(); 
    }

    // Attendance Entries
    // Document ID is typically {studentId}_{YYYY-MM-DD}
    match /attendanceEntries/{attendanceEntryId} {
      // Admins can read all attendance.
      // Teachers can read attendance they marked.
      // Students can read their own attendance (requires client to query by studentId).
      allow read: if isAdmin() ||
                     (isTeacher() && resource.data.markedByTeacherId == request.auth.uid) ||
                     (resource.data.studentId == attendanceEntryId.split('_')[0]); // Basic check, assuming studentId is part of docId.
                                                                                    // Better to secure with a query constraint if students fetch.
      
      // Teachers can create/update attendance, ensuring they are the marker and doc ID format is correct.
      allow create, update: if isTeacher()
                              && request.resource.data.markedByTeacherId == request.auth.uid
                              && attendanceEntryId.startsWith(request.resource.data.studentId + '_');
      // allow delete: if isAdmin(); // Or if teacher should be able to delete recent entries
    }

    // Assignments
    // Document ID is auto-generated
    match /assignments/{assignmentId} {
      // Admins can read all assignments.
      // Teachers can read assignments they created.
      // Students can read assignments for their class (requires client to filter or query by classId).
      allow read: if isAdmin() || isTeacher(); // Student read access needs more specific logic if directly from client.
      
      // Teachers can create assignments, ensuring they are the author.
      allow create: if isTeacher() && request.resource.data.teacherId == request.auth.uid;
      
      // Only the teacher who created the assignment can update or delete it.
      allow update, delete: if isTeacher() && resource.data.teacherId == request.auth.uid;
    }

    // Behavior Incidents
    // Document ID is auto-generated
    match /behaviorIncidents/{incidentId} {
      // Admins can read all incidents.
      // Teachers can read incidents they logged.
      // Students can read their own incidents (requires client to query by studentId).
      allow read: if isAdmin() || 
                     (isTeacher() && resource.data.teacherId == request.auth.uid);
                     // Student read access needs client-side filtering or specific query.

      // Teachers can log incidents, ensuring they are the logger.
      allow create: if isTeacher() && request.resource.data.teacherId == request.auth.uid;
      
      // Only the teacher who logged the incident can update or delete it.
      allow update, delete: if isTeacher() && resource.data.teacherId == request.auth.uid;
    }

    // Timetable Entries
    // Document ID is {teacherId}_{dayOfWeek}
    match /timetableEntries/{timetableEntryId} {
      // Admins and the teacher who owns the timetable can read it.
      // Students might read timetables if their class is involved (complex rule, simplified here).
      allow read: if isAdmin() || (isTeacher() && resource.data.teacherId == request.auth.uid);
      
      // Teachers can create their own timetable entries, ensuring docId and teacherId field match their UID.
      allow create: if isTeacher()
                      && request.resource.data.teacherId == request.auth.uid
                      && timetableEntryId.startsWith(request.auth.uid + '_');
      
      // Teachers can update their own timetable entries.
      allow update: if isTeacher()
                      && resource.data.teacherId == request.auth.uid // Check existing document
                      && request.resource.data.teacherId == request.auth.uid // Check incoming data
                      && timetableEntryId.startsWith(request.auth.uid + '_');
      
      // Teachers can delete their own timetable entries.
      allow delete: if isTeacher()
                      && resource.data.teacherId == request.auth.uid
                      && timetableEntryId.startsWith(request.auth.uid + '_');
    }
  }
}
