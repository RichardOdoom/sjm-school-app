
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // ======= Helper Functions =======
    function isAuthenticated() {
      return request.auth != null;
    }

    function isAdmin() {
      // This assumes you have a custom claim 'isAdmin' set to true for admin users.
      return isAuthenticated() && request.auth.token.isAdmin == true;
    }

    // Helper to parse HH:mm time string to minutes since midnight for comparison
    function parseTime(timeStr) {
      return int(timeStr.split(':')[0]) * 60 + int(timeStr.split(':')[1]);
    }

    // Helper to validate teacher profile updates
    function isTeacherProfileUpdateValid(requestData, resourceData) {
      return requestData.fullName is string && requestData.fullName.size() > 0
             && requestData.subjectsTaught is string // Or list, adjust as needed
             && requestData.contactNumber is string
             && requestData.assignedClasses is list
             // Fields that should NOT change or be set by teacher directly
             && requestData.email == resourceData.email
             && requestData.uid == resourceData.uid
             && (!('role' in requestData) || requestData.role == resourceData.role); // Role shouldn't be changed by teacher
    }

    // ======= App Settings =======
    match /appSettings/general {
      allow read: if true;
      allow write: if isAdmin();
    }

    // ======= Students =======
    match /students/{studentId} {
      allow read: if isAuthenticated(); // Admins and Teachers can read. Client filters for teachers.
      allow create, update, delete: if isAdmin();
    }

    // ======= Teachers =======
    match /teachers/{teacherId} {
      allow read: if isAdmin() || (isAuthenticated() && request.auth.uid == teacherId);
      allow create: if isAdmin(); // Assuming only admins create teacher accounts initially via backend/console
      allow update: if (isAdmin()) || (isAuthenticated() && request.auth.uid == teacherId && isTeacherProfileUpdateValid(request.resource.data, resource.data));
      allow delete: if isAdmin();
    }

    // ======= Payments =======
    match /payments/{paymentId} {
      allow read: if isAuthenticated(); // Client-side logic filters for relevant user.
      allow create: if isAdmin();
      allow update, delete: if isAdmin();
    }

    // ======= Assignments =======
    match /assignments/{assignmentId} {
      function isAssignmentDataValid(data) {
        return data.title is string && data.title.size() > 0
               && data.description is string && data.description.size() > 0
               && data.classId is string && data.classId.size() > 0
               && data.dueDate is timestamp
               && data.teacherId == request.auth.uid
               && data.teacherName is string;
      }

      allow read: if isAuthenticated();
      allow create: if isAuthenticated()
                      && isAssignmentDataValid(request.resource.data)
                      && request.resource.data.createdAt == request.time;
      allow update: if isAuthenticated()
                      && resource.data.teacherId == request.auth.uid
                      && isAssignmentDataValid(request.resource.data)
                      && request.resource.data.teacherId == resource.data.teacherId
                      && request.resource.data.createdAt == resource.data.createdAt; // createdAt immutable
      allow delete: if isAuthenticated() && resource.data.teacherId == request.auth.uid;
    }

    // ======= Attendance Entries =======
    match /attendanceEntries/{entryId} {
      function isAttendanceEntryDataValid(data, isCreate) {
        let commonChecks = data.studentId is string
                           && data.studentName is string
                           && data.className is string
                           && data.date is timestamp
                           && data.status in ['present', 'absent', 'late']
                           && data.notes is string
                           && data.markedByTeacherId == request.auth.uid
                           && data.markedByTeacherName is string;
        if (isCreate) {
          return commonChecks && data.lastUpdatedAt == request.time;
        } else { // isUpdate
          return commonChecks
                 && data.studentId == resource.data.studentId
                 && data.className == resource.data.className
                 && data.date == resource.data.date // Date of attendance cannot change
                 && data.lastUpdatedAt == request.time;
        }
      }

      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && isAttendanceEntryDataValid(request.resource.data, true);
      allow update: if isAuthenticated()
                      && resource.data.markedByTeacherId == request.auth.uid
                      && isAttendanceEntryDataValid(request.resource.data, false);
      allow delete: if isAuthenticated() && resource.data.markedByTeacherId == request.auth.uid;
    }

    // ======= Timetable Entries =======
    match /timetableEntries/{entryId} {
      function isTimetableDocIdValid(docId) {
        // Ensure docId starts with the authenticated user's UID followed by an underscore.
        // Example: "someUserId_Monday". Regex matches UID_DayName.
        return docId.matches(request.auth.uid + '_[A-Za-z]+');
      }

      function isTimetableDataValid(data) {
        // Basic structure and owner check
        let baseValid = data.teacherId == request.auth.uid
                        && data.dayOfWeek is string
                        && data.periods is list;

        // If periods list is not empty, validate the first period object's structure
        // This is a common compromise in Firestore rules for validating list elements.
        let periodsValid = data.periods.size() == 0 || (
                             data.periods.size() > 0 &&
                             data.periods[0].startTime is string && data.periods[0].startTime.matches('^[0-2][0-9]:[0-5][0-9]$') &&
                             data.periods[0].endTime is string && data.periods[0].endTime.matches('^[0-2][0-9]:[0-5][0-9]$') &&
                             (parseTime(data.periods[0].endTime) > parseTime(data.periods[0].startTime)) && // End time after start time
                             data.periods[0].subjects is list &&
                             (data.periods[0].subjects.size() == 0 || data.periods[0].subjects[0] is string) &&
                             data.periods[0].classNames is list &&
                             (data.periods[0].classNames.size() == 0 || data.periods[0].classNames[0] is string)
                           );
        return baseValid && periodsValid;
      }

      function isTimetableOwner(timetableDocData) {
        return timetableDocData.keys().hasAll(['teacherId'])
               && timetableDocData.teacherId is string
               && timetableDocData.teacherId == request.auth.uid;
      }

      allow read: if isAuthenticated() && isTimetableOwner(resource.data);

      allow create: if isAuthenticated()
                      && isTimetableDataValid(request.resource.data)
                      && request.resource.data.createdAt == request.time
                      && request.resource.data.updatedAt == request.time
                      && isTimetableDocIdValid(entryId);

      allow update: if isAuthenticated()
                      && isTimetableOwner(resource.data) // Original owner
                      && isTimetableDataValid(request.resource.data) // New data is valid
                      && request.resource.data.teacherId == resource.data.teacherId // teacherId immutable
                      && request.resource.data.dayOfWeek == resource.data.dayOfWeek // dayOfWeek (part of ID) immutable
                      && request.resource.data.createdAt == resource.data.createdAt // createdAt immutable
                      && request.resource.data.updatedAt == request.time // updatedAt must be server timestamp
                      && isTimetableDocIdValid(entryId); // entryId must still be valid

      allow delete: if isAuthenticated()
                      && isTimetableOwner(resource.data)
                      && isTimetableDocIdValid(entryId);
    }
  }
}

    