
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper Functions
    function isAdmin() {
      // Ensure isAdmin claim exists and is true.
      // You need to set this custom claim for your admin users via Firebase Admin SDK or console.
      return request.auth != null && request.auth.token.isAdmin == true;
    }

    // Students Collection
    match /students/{studentId} {
      // Admins can manage all student records.
      allow read, list: if request.auth != null && isAdmin();
      // Students can read their own record if client fetches by specific studentId (no Firebase Auth for students)
      // This rule is broad for student clients; consider tightening if students get Firebase Auth.
      allow get: if true; // Assuming student app fetches own ID.
      allow create, update, delete: if request.auth != null && isAdmin();
    }

    // Teachers Collection
    match /teachers/{teacherId} {
      // Admins can manage all. Teachers can read/update own (not role).
      allow get: if request.auth != null && (isAdmin() || request.auth.uid == teacherId);
      allow list: if request.auth != null && isAdmin(); // Only admins list all teachers.
      allow create: if request.auth != null && isAdmin(); // Only admins create teachers initially.
      allow update: if request.auth != null && 
                      (isAdmin() || 
                       (request.auth.uid == teacherId && request.resource.data.role == resource.data.role && request.resource.data.uid == resource.data.uid && request.resource.data.email == resource.data.email) ); // Teacher updates own, cannot change role, uid, email.
      allow delete: if request.auth != null && isAdmin();
    }

    // Payments Collection
    match /payments/{paymentId} {
      // Admins can manage all payments.
      allow read, write: if request.auth != null && isAdmin();
      // Students can read their own payments if client queries specifically by their studentId
      allow list: if request.auth == null && request.query.filters.find(f => f[0] == 'studentId' && f[1] == '==') != null;
      allow get: if request.auth == null && resource.data.studentId != null; // Assuming studentId is on the doc for direct get
    }

    // App Settings (like school name, academic year, branding)
    match /appSettings/{settingId} {
      allow read: if true; // General settings often public.
      allow write: if request.auth != null && isAdmin(); // Only admins modify.
    }

    // Attendance Entries
    match /attendanceEntries/{attendanceEntryId} {
      function isAttendanceTeacher() {
        return request.auth != null && resource.data.keys().has('markedByTeacherId') && resource.data.markedByTeacherId == request.auth.uid;
      }
      function isCreatingOwnAttendance() {
         return request.auth != null && request.resource.data.markedByTeacherId == request.auth.uid;
      }
      
      // Admins can read all. Teachers can read attendance they marked. Students read their own.
      allow get: if request.auth != null && (isAdmin() || isAttendanceTeacher()) ||
                    (request.auth == null && resource.data.keys().has('studentId') && resource.data.studentId != null) ; 
      
      // Admins list all. Teachers list what they marked. Students list their own.
      allow list: if (request.auth != null && isAdmin()) ||
                     (request.auth != null && request.query.filters.find(f => f[0] == 'markedByTeacherId' && f[1] == '==' && f[2] == request.auth.uid) != null) ||
                     (request.auth == null && request.query.filters.find(f => f[0] == 'studentId' && f[1] == '==') != null);
                     
      allow create: if request.auth != null && isCreatingOwnAttendance() && request.resource.data.date is timestamp;
      allow update: if request.auth != null && isAttendanceTeacher() && isCreatingOwnAttendance() && request.resource.data.date == resource.data.date; // Teacher can update their own markings, date immutable
      allow delete: if request.auth != null && (isAdmin() || isAttendanceTeacher());
    }

    // Assignments Collection
    match /assignments/{assignmentId} {
        function isAssignmentOwner() {
            return request.auth != null && resource.data.keys().has('teacherId') && resource.data.teacherId == request.auth.uid;
        }
        function isCreatingOwnAssignment() {
            return request.auth != null && request.resource.data.teacherId == request.auth.uid;
        }
        function isValidAssignmentData() {
            return request.resource.data.teacherId is string &&
                   request.resource.data.classId is string &&
                   request.resource.data.title is string &&
                   request.resource.data.description is string &&
                   request.resource.data.dueDate is timestamp &&
                   request.resource.data.createdAt is timestamp;
        }

        // Admins: R/W all. Teachers: R/W own. Students: Read for their classId.
        allow get: if request.auth != null && (isAdmin() || isAssignmentOwner()) ||
                      (request.auth == null && resource.data.keys().has('classId')); // Student get by ID for their class
        allow list: if (request.auth != null && isAdmin()) ||
                       (request.auth != null && request.query.filters.find(f => f[0] == 'teacherId' && f[1] == '==' && f[2] == request.auth.uid) != null) || // Teacher lists own
                       (request.auth == null && request.query.filters.find(f => f[0] == 'classId' && f[1] == '==') != null); // Student lists for their class

        allow create: if request.auth != null && isCreatingOwnAssignment() && isValidAssignmentData() && request.resource.data.createdAt == request.time;
        allow update: if request.auth != null && isAssignmentOwner() && isCreatingOwnAssignment() && isValidAssignmentData() && request.resource.data.createdAt == resource.data.createdAt; // Cannot change createdAt
        allow delete: if request.auth != null && isAssignmentOwner();
    }

    // Behavior Incidents Collection
    match /behaviorIncidents/{incidentId} {
        function isIncidentReporter() {
            return request.auth != null && resource.data.keys().has('teacherId') && resource.data.teacherId == request.auth.uid;
        }
        function isCreatingOwnIncident() {
            return request.auth != null && request.resource.data.teacherId == request.auth.uid;
        }
        function isValidIncidentData() {
            return request.resource.data.studentId is string &&
                   request.resource.data.studentName is string &&
                   request.resource.data.classId is string &&
                   request.resource.data.teacherId is string &&
                   request.resource.data.teacherName is string &&
                   request.resource.data.type is string &&
                   request.resource.data.description is string &&
                   request.resource.data.date is timestamp &&
                   request.resource.data.createdAt is timestamp;
        }
        
        // Admins: R/W all. Teachers: R/W own. Students: (More complex, typically not direct read for privacy unless carefully scoped).
        allow read: if request.auth != null && (isAdmin() || isIncidentReporter()); 
        allow list: if request.auth != null && (isAdmin() || 
                      (request.query.filters.find(f => f[0] == 'teacherId' && f[1] == '==' && f[2] == request.auth.uid) != null) || // Teacher lists own reports
                      (request.query.filters.find(f => f[0] == 'studentId') != null)); // Admin/Teacher can list by studentId

        allow create: if request.auth != null && isCreatingOwnIncident() && isValidIncidentData() && request.resource.data.createdAt == request.time;
        allow update: if request.auth != null && isIncidentReporter() && isCreatingOwnIncident() && isValidIncidentData() && request.resource.data.createdAt == resource.data.createdAt;
        allow delete: if request.auth != null && (isAdmin() || isIncidentReporter());
    }

    // Timetable Entries
    match /timetableEntries/{entryId} {
      function isTimetableOwner() {
        // CRUCIAL: Check teacherId field exists before comparing
        return request.auth != null && 
               resource.data.keys().has('teacherId') && 
               resource.data.teacherId == request.auth.uid;
      }
      function isCreatingOwnTimetable() {
        return request.auth != null && request.resource.data.teacherId == request.auth.uid;
      }
      function isValidTimetableStructure() {
        return request.resource.data.teacherId is string &&
               request.resource.data.dayOfWeek is string &&
               request.resource.data.dayOfWeek in ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'] &&
               request.resource.data.periods is list &&
               request.resource.data.createdAt is timestamp &&
               (request.resource.data.updatedAt is timestamp || request.resource.data.updatedAt == null);
      }
      // function allPeriodsAreValid(periodsList) {
      //   // Placeholder for detailed period validation if needed (e.g., time formats, subject/class arrays not empty)
      //   return periodsList.size() == 0 || periodsList.forall(p, 
      //     p.startTime is string && p.endTime is string && p.subjects is list && p.classNames is list && p.subjects.size() > 0 && p.classNames.size() > 0
      //   );
      // }

      // Allows a teacher to read/list only their own timetable entries.
      // Client query must include where("teacherId", "==", request.auth.uid).
      allow read: if isTimetableOwner(); // This applies to both get and list

      allow create: if isCreatingOwnTimetable() &&
                      isValidTimetableStructure() &&
                      // allPeriodsAreValid(request.resource.data.periods) && // Uncomment and refine if strict period validation needed
                      request.resource.data.createdAt == request.time &&
                      request.resource.data.updatedAt == request.time &&
                      entryId.startsWith(request.auth.uid + '_') &&
                      entryId == request.auth.uid + '_' + request.resource.data.dayOfWeek;

      allow update: if isTimetableOwner() && 
                      isCreatingOwnTimetable() && 
                      isValidTimetableStructure() &&
                      // allPeriodsAreValid(request.resource.data.periods) && // Uncomment and refine
                      request.resource.data.teacherId == resource.data.teacherId && 
                      request.resource.data.createdAt == resource.data.createdAt && 
                      request.resource.data.updatedAt == request.time &&
                      entryId.startsWith(request.auth.uid + '_') &&
                      entryId == request.auth.uid + '_' + request.resource.data.dayOfWeek;

      allow delete: if isTimetableOwner() && entryId.startsWith(request.auth.uid + '_');
    }
  }
}

    