
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // ============== Helper Functions ==============
    function isAuthenticated() {
      return request.auth != null;
    }

    function isAdmin() {
      return isAuthenticated() && request.auth.token.isAdmin == true;
    }

    function isTeacherProfileUpdateValid(requestData, resourceData) {
      let allowedChanges = requestData.fullName is string && requestData.fullName.size() > 0
                           && requestData.contactNumber is string; // subjectsTaught and assignedClasses managed by admin

      let immutableFieldsProtected = requestData.email == resourceData.email
                                  && requestData.uid == resourceData.uid
                                  && (!requestData.keys().has('role') || requestData.role == resourceData.role)
                                  && requestData.subjectsTaught == resource.data.subjectsTaught
                                  && requestData.assignedClasses == resource.data.assignedClasses;

      return allowedChanges && immutableFieldsProtected;
    }
    
    function isTimetableDocIdValid(docId, userId) {
      return docId.size() > userId.size() + 1 && docId.matches(userId + '_[A-Za-z]+');
    }

    function isTimetableDataValid(data, userId) {
      let periodsStructureIsValid = data.periods is list &&
                                    (data.periods.size() == 0 ||
                                      (data.periods.size() > 0 &&
                                        data.periods[0].keys().hasAll(['startTime', 'endTime', 'subjects', 'classNames']) &&
                                        data.periods[0].startTime is string && data.periods[0].startTime.matches('^[0-2][0-9]:[0-5][0-9]$') &&
                                        data.periods[0].endTime is string && data.periods[0].endTime.matches('^[0-2][0-9]:[0-5][0-9]$') &&
                                        (data.periods[0].startTime < data.periods[0].endTime || data.periods[0].startTime == data.periods[0].endTime) &&
                                        data.periods[0].subjects is list && (data.periods[0].subjects.size() == 0 || data.periods[0].subjects[0] is string) &&
                                        data.periods[0].classNames is list && (data.periods[0].classNames.size() == 0 || data.periods[0].classNames[0] is string)
                                      )
                                    );

      return data.keys().hasAll(['teacherId', 'teacherName', 'dayOfWeek', 'periods', 'updatedAt'])
             && data.teacherId == userId
             && data.teacherName is string // Added teacherName check
             && data.dayOfWeek is string
             && periodsStructureIsValid;
    }


    // ============== App Settings ==============
    match /appSettings/general {
      allow read: if true;
      allow write: if isAdmin();
    }

    // ============== Students ==============
    match /students/{studentId} {
      allow get: if true;
      allow list: if isAuthenticated(); // Admins and Teachers can list, client filters.
      allow write: if isAdmin(); // create, update, delete by admin
      // More specific get for teachers if needed
      allow get: if isAdmin() || (isAuthenticated() && request.auth.uid != null && exists(/databases/$(database)/documents/teachers/$(request.auth.uid)) && resource.data.gradeLevel in get(/databases/$(database)/documents/teachers/$(request.auth.uid)).data.assignedClasses);
    }

    // ============== Teachers ==============
    match /teachers/{teacherId} {
      allow read, write: if isAdmin(); // Admin full access
      allow read: if isAuthenticated() && request.auth.uid == teacherId && !isAdmin();
      allow update: if isAuthenticated() && request.auth.uid == teacherId
                      && isTeacherProfileUpdateValid(request.resource.data, resource.data)
                      && !isAdmin();
      allow delete: if isAdmin();

      // Teacher-specific settings subcollection
      match /userSettings/preferences {
        allow read, write: if isAuthenticated() && request.auth.uid == teacherId;
      }
    }

    // ============== Payments ==============
    match /payments/{paymentId} {
      allow read: if isAuthenticated();
      allow create, update, delete: if isAdmin();
    }

    // ============== Assignments ==============
    match /assignments/{assignmentId} {
      function isAssignmentOwner() {
        return resource.data.teacherId == request.auth.uid;
      }
      function isAssignmentDataValidForCreate() {
        return request.resource.data.keys().hasAll(['teacherId', 'teacherName', 'classId', 'title', 'description', 'dueDate', 'createdAt'])
               && request.resource.data.teacherId == request.auth.uid
               && request.resource.data.teacherName is string
               && request.resource.data.classId is string && request.resource.data.classId.size() > 0
               && request.resource.data.title is string && request.resource.data.title.size() > 0
               && request.resource.data.description is string && request.resource.data.description.size() > 0
               && request.resource.data.dueDate is timestamp
               && request.resource.data.createdAt == request.time;
      }
      function isAssignmentDataValidForUpdate() {
        let commonFieldsValid = request.resource.data.keys().hasAll(['classId', 'title', 'description', 'dueDate'])
               && request.resource.data.classId is string && request.resource.data.classId.size() > 0
               && request.resource.data.title is string && request.resource.data.title.size() > 0
               && request.resource.data.description is string && request.resource.data.description.size() > 0
               && request.resource.data.dueDate is timestamp;
        let immutableFieldsProtected = request.resource.data.teacherId == resource.data.teacherId
               && request.resource.data.teacherName == resource.data.teacherName
               && request.resource.data.createdAt == resource.data.createdAt;
        return commonFieldsValid && immutableFieldsProtected;
      }

      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && isAssignmentDataValidForCreate();
      allow update: if isAuthenticated() && isAssignmentOwner() && isAssignmentDataValidForUpdate();
      allow delete: if isAuthenticated() && isAssignmentOwner();
    }
    
    // ============== Assignment Submissions ==============
    match /assignmentSubmissions/{submissionId} {
        function isSubmissionOwner() {
            // Assuming submission document has 'studentId' and 'teacherId' (who graded)
            // This rule might be tricky if studentId is not directly auth.uid
            // For now, focusing on teacher/admin access
            return resource.data.teacherId == request.auth.uid; // If teacher graded
        }
        function canStudentRead() {
            // This is difficult without student Firebase Auth.
            // A placeholder for now: allows any authenticated user to get, client must filter.
            // In a real app, student ID would be part of the query or document path.
            return isAuthenticated() && request.method == 'get';
        }
        function canStudentListOwn() {
            // Again, tricky. Requires query constraints.
            // Limit list for general authenticated to very small, client must add studentId filter.
            return isAuthenticated() && request.method == 'list' && request.query.limit <= 5;
        }

        allow read: if isAdmin() || (isAuthenticated() && isSubmissionOwner()) || canStudentRead() || canStudentListOwn();
        
        allow create, update: if isAdmin() || (isAuthenticated() && 
            ( (request.resource.data.teacherId == request.auth.uid && request.resource.data.graded == true) // Teacher grading
             // Add student submission rule if students can submit directly
            )
        );
        allow delete: if isAdmin();
    }

    // ============== Attendance Entries ==============
    match /attendanceEntries/{entryId} {
      function isAttendanceOwner() {
        return resource.data.markedByTeacherId == request.auth.uid;
      }
      function isAttendanceDataValidForCreate() {
        return request.resource.data.keys().hasAll(['studentId', 'studentName', 'className', 'date', 'status', 'notes', 'markedByTeacherId', 'markedByTeacherName', 'lastUpdatedAt'])
               && request.resource.data.studentId is string
               && request.resource.data.studentName is string
               && request.resource.data.className is string
               && request.resource.data.date is timestamp
               && request.resource.data.status in ['present', 'absent', 'late']
               && request.resource.data.notes is string
               && request.resource.data.markedByTeacherId == request.auth.uid
               && request.resource.data.markedByTeacherName is string
               && request.resource.data.lastUpdatedAt == request.time;
      }
      function isAttendanceDataValidForUpdate() {
        let updatableFieldsValid = request.resource.data.keys().hasAll(['status', 'notes', 'lastUpdatedAt'])
               && request.resource.data.status in ['present', 'absent', 'late']
               && request.resource.data.notes is string
               && request.resource.data.lastUpdatedAt == request.time;
        let immutableFieldsProtected = request.resource.data.studentId == resource.data.studentId
               && request.resource.data.studentName == resource.data.studentName
               && request.resource.data.className == resource.data.className
               && request.resource.data.date == resource.data.date
               && request.resource.data.markedByTeacherId == resource.data.markedByTeacherId
               && request.resource.data.markedByTeacherName == resource.data.markedByTeacherName;
        return updatableFieldsValid && immutableFieldsProtected;
      }

      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && isAttendanceDataValidForCreate();
      allow update: if isAuthenticated() && isAttendanceOwner() && isAttendanceDataValidForUpdate();
      allow delete: if isAuthenticated() && isAttendanceOwner();
    }

    // ============== Timetable Entries ==============
    match /timetableEntries/{entryId} {
      function isTimetableEntryOwner(entryData) {
        return entryData.keys().has('teacherId') &&
               entryData.teacherId is string &&
               entryData.teacherId == request.auth.uid;
      }

      allow read: if true; // Simplified for student access, client filters. Was: isAuthenticated() && isTimetableEntryOwner(resource.data)
      allow create: if isAuthenticated()
                      && isTimetableDataValid(request.resource.data, request.auth.uid)
                      && request.resource.data.createdAt == request.time
                      && request.resource.data.updatedAt == request.time
                      && isTimetableDocIdValid(entryId, request.auth.uid);
      allow update: if isAuthenticated()
                      && isTimetableEntryOwner(resource.data)
                      && isTimetableDataValid(request.resource.data, request.auth.uid)
                      && request.resource.data.teacherId == resource.data.teacherId
                      && request.resource.data.dayOfWeek == resource.data.dayOfWeek
                      && request.resource.data.createdAt == resource.data.createdAt
                      && request.resource.data.updatedAt == request.time
                      && isTimetableDocIdValid(entryId, request.auth.uid);
      allow delete: if isAuthenticated()
                      && isTimetableEntryOwner(resource.data)
                      && isTimetableDocIdValid(entryId, request.auth.uid);
    }

    // ============== Behavior Incidents ==============
    match /behaviorIncidents/{incidentId} {
        function isIncidentCreator() {
            return resource.data.teacherId == request.auth.uid;
        }
        function isIncidentDataValid() {
            return request.resource.data.keys().hasAll(['studentId', 'studentName', 'classId', 'teacherId', 'teacherName', 'type', 'description', 'date', 'createdAt'])
                && request.resource.data.studentId is string
                && request.resource.data.studentName is string
                && request.resource.data.classId is string
                && request.resource.data.teacherId == request.auth.uid // Ensure creator is the authenticated user
                && request.resource.data.teacherName is string
                && request.resource.data.type is string
                && request.resource.data.description is string
                && request.resource.data.date is timestamp
                && (request.method == 'create' ? request.resource.data.createdAt == request.time : request.resource.data.createdAt == resource.data.createdAt); // createdAt immutable on update
        }

        allow read: if isAuthenticated(); // Teachers can list, students might get specific ones if ID is known (client filters)

        allow create: if isAuthenticated() && isIncidentDataValid();
        
        allow update: if isAuthenticated() && isIncidentCreator() && isIncidentDataValid();

        allow delete: if isAuthenticated() && isIncidentCreator();
    }
  }
}
